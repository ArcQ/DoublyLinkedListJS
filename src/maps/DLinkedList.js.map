{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/DLinkedList.js","DLinkedList.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length",1,"module","dLinkedList","this","head","tail","makeNode","obj","node","next","prev","prototype","push","newNode","insertAfter","refNode","inObj","nextNode","insertBefore","prevNode","findFirst","currentNode","remove","delNode","applyToEveryNode","callback","arguments","ccObstacles","typesList","isContinue","window"],"mappings":"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","file":"DLinkedList.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","//LinkedList for objects\n//Many methods are based on the assumption that objects will consist of specific ids\nvar dLinkedList = function(){\n\tthis.head = null;\n\tthis.tail = null;\n};\n\ndLinkedList.makeNode = function(obj){\n\tvar node = {\n\t\tobj: obj,\n\t\tnext: null,\n\t\tprev: null\n\t};\n\n\treturn node;\n};\n\ndLinkedList.prototype.push = function(obj){\n\tvar newNode = dLinkedList.makeNode(obj);\n\n\tif(this.head === null){\n\t\tthis.head = newNode;\n\t}\n\telse{\n\t\tif(this.tail !== null){\n\t\t\tthis.tail.next = newNode;\n\t\t\tnewNode.prev = this.tail;\n\t\t}\n\t\telse{\n\t\t\tthis.head.next = newNode;\n\t\t\tnewNode.prev = this.head;\n\t\t}\n\t\tthis.tail = newNode;\n\t}\n}\n\ndLinkedList.prototype.insertAfter = function(refNode,inObj){\n\t\n\tvar newNode = dLinkedList.makeNode(inObj);\n\n\tif((this.tail === null)||(this.tail === refNode)){\n\t\t//only scenario this happens is if you only have one head node\n\t\tthis.tail = newNode;\n\t\tnewNode.prev = refNode;\n\t\trefNode.next = newNode;\n\t}\n\telse{\n\t\tvar nextNode = refNode.next;\n\n\t\t//insert node inbetween\n\t\trefNode.next = newNode;\n\t\tnewNode.prev = this.refNode;\n\t\tnewNode.next = nextNode;\n\t\tnextNode.prev = newNode.next;\n\t}\n\treturn newNode;\n};\n\ndLinkedList.prototype.insertBefore = function(refNode,inObj){\n\tvar newNode = dLinkedList.makeNode(inObj);\n\t//if list only has one element\n\tif(this.tail === null){\n\t\tthis.tail = refNode;\n\t\trefNode.prev = newNode;\n\t\tthis.head = newNode;\n\t}\n\telse{\n\t\tvar prevNode = refNode.prev;\n\t\trefNode.prev = newNode;\n\t\tnewNode.next = refNode;\n\t\t//if refNode doesn't have a prev, it is the head of the list and the head needs to be changed\n\t\tif(prevNode === null){\n\t\t\tthis.head = newNode;\n\t\t}\n\t\telse{\n\t\t\tprevNode.next = newNode;\n\t\t\tnewNode.prev = prevNode;\n\t\t}\n\t}\n\n\treturn newNode;\n};\n//finds the first node that has the obj\ndLinkedList.prototype.findFirst = function(obj){\n\tvar currentNode = this.head;\n\twhile(currentNode !== null){\n\t\tif(currentNode.obj === obj){\n\t\t\treturn currentNode;\n\t\t}\n\t\tcurrentNode = currentNode.next;\n\t}\n\treturn undefined;\n};\n\ndLinkedList.prototype.remove = function(delNode){\n\tvar prevNode = null;\n\tvar currentNode = this.head;\n\n\twhile(currentNode !== null){\n\n\t\tif(currentNode === delNode){\n\n\t\t\tif(currentNode === this.head){\n\t\t\t\tvar nextNode = currentNode.next;\n\t\t\t\tthis.head = nextNode;\n\t\t\t\tthis.head.prev = null;\n\t\t\t}\n\t\t\telse if(currentNode === this.tail){\n\t\t\t\tthis.tail = currentNode.prev;\n\t\t\t\tthis.tail.next = null;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tvar nextNode = currentNode.next;\n\t\t\t\tprevNode.next = nextNode;\n\t\t\t\tnextNode.prev = prevNode;\n\t\t\t}\n\t\t\tcurrentNode = null;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tprevNode = currentNode;\n\t\tcurrentNode = currentNode.next;\n\t}\n\n\treturn false;\n};\n\n//callback returns true if continue\ndLinkedList.prototype.applyToEveryNode = function(callback){\n\n\t\tvar callback = arguments[0];\n    var currentNode = ccObstacles.typesList.head;\n    callback(currentNode);\n    currentNode = currentNode.next;\n    while(currentNode != null){\n        var isContinue = callback(currentNode);\n        if(isContinue === true){\n        \tbreak;\n        }\n        currentNode = currentNode.next;\n    }\n};\n\nwindow.dLinkedList = dLinkedList;\n\nmodule.exports = dLinkedList;\n","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n//LinkedList for objects\n//Many methods are based on the assumption that objects will consist of specific ids\nvar dLinkedList = function(){\n\tthis.head = null;\n\tthis.tail = null;\n};\n\ndLinkedList.makeNode = function(obj){\n\tvar node = {\n\t\tobj: obj,\n\t\tnext: null,\n\t\tprev: null\n\t};\n\n\treturn node;\n};\n\ndLinkedList.prototype.push = function(obj){\n\tvar newNode = dLinkedList.makeNode(obj);\n\n\tif(this.head === null){\n\t\tthis.head = newNode;\n\t}\n\telse{\n\t\tif(this.tail !== null){\n\t\t\tthis.tail.next = newNode;\n\t\t\tnewNode.prev = this.tail;\n\t\t}\n\t\telse{\n\t\t\tthis.head.next = newNode;\n\t\t\tnewNode.prev = this.head;\n\t\t}\n\t\tthis.tail = newNode;\n\t}\n}\n\ndLinkedList.prototype.insertAfter = function(refNode,inObj){\n\t\n\tvar newNode = dLinkedList.makeNode(inObj);\n\n\tif((this.tail === null)||(this.tail === refNode)){\n\t\t//only scenario this happens is if you only have one head node\n\t\tthis.tail = newNode;\n\t\tnewNode.prev = refNode;\n\t\trefNode.next = newNode;\n\t}\n\telse{\n\t\tvar nextNode = refNode.next;\n\n\t\t//insert node inbetween\n\t\trefNode.next = newNode;\n\t\tnewNode.prev = this.refNode;\n\t\tnewNode.next = nextNode;\n\t\tnextNode.prev = newNode.next;\n\t}\n\treturn newNode;\n};\n\ndLinkedList.prototype.insertBefore = function(refNode,inObj){\n\tvar newNode = dLinkedList.makeNode(inObj);\n\t//if list only has one element\n\tif(this.tail === null){\n\t\tthis.tail = refNode;\n\t\trefNode.prev = newNode;\n\t\tthis.head = newNode;\n\t}\n\telse{\n\t\tvar prevNode = refNode.prev;\n\t\trefNode.prev = newNode;\n\t\tnewNode.next = refNode;\n\t\t//if refNode doesn't have a prev, it is the head of the list and the head needs to be changed\n\t\tif(prevNode === null){\n\t\t\tthis.head = newNode;\n\t\t}\n\t\telse{\n\t\t\tprevNode.next = newNode;\n\t\t\tnewNode.prev = prevNode;\n\t\t}\n\t}\n\n\treturn newNode;\n};\n//finds the first node that has the obj\ndLinkedList.prototype.findFirst = function(obj){\n\tvar currentNode = this.head;\n\twhile(currentNode !== null){\n\t\tif(currentNode.obj === obj){\n\t\t\treturn currentNode;\n\t\t}\n\t\tcurrentNode = currentNode.next;\n\t}\n\treturn undefined;\n};\n\ndLinkedList.prototype.remove = function(delNode){\n\tvar prevNode = null;\n\tvar currentNode = this.head;\n\n\twhile(currentNode !== null){\n\n\t\tif(currentNode === delNode){\n\n\t\t\tif(currentNode === this.head){\n\t\t\t\tvar nextNode = currentNode.next;\n\t\t\t\tthis.head = nextNode;\n\t\t\t\tthis.head.prev = null;\n\t\t\t}\n\t\t\telse if(currentNode === this.tail){\n\t\t\t\tthis.tail = currentNode.prev;\n\t\t\t\tthis.tail.next = null;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tvar nextNode = currentNode.next;\n\t\t\t\tprevNode.next = nextNode;\n\t\t\t\tnextNode.prev = prevNode;\n\t\t\t}\n\t\t\tcurrentNode = null;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tprevNode = currentNode;\n\t\tcurrentNode = currentNode.next;\n\t}\n\n\treturn false;\n};\n\n//callback returns true if continue\ndLinkedList.prototype.applyToEveryNode = function(callback){\n\n\t\tvar callback = arguments[0];\n    var currentNode = ccObstacles.typesList.head;\n    callback(currentNode);\n    currentNode = currentNode.next;\n    while(currentNode != null){\n        var isContinue = callback(currentNode);\n        if(isContinue === true){\n        \tbreak;\n        }\n        currentNode = currentNode.next;\n    }\n};\n\nwindow.dLinkedList = dLinkedList;\n\nmodule.exports = dLinkedList;\n\n},{}]},{},[1])\n\n"],"sourceRoot":"/source/"}