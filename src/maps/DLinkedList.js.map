{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/DLinkedList.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"DLinkedList.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","//LinkedList for objects\n//Many methods are based on the assumption that objects will consist of specific ids\nvar dLinkedList = function(){\n\tthis.head = null;\n\tthis.tail = null;\n};\n\ndLinkedList.makeNode = function(obj){\n\tvar node = {\n\t\tobj: obj,\n\t\tnext: null,\n\t\tprev: null\n\t};\n\n\treturn node;\n};\n\ndLinkedList.prototype.push = function(obj){\n\tvar newNode = dLinkedList.makeNode(obj);\n\n\tif(this.head === null){\n\t\tthis.head = newNode;\n\t}\n\telse{\n\t\tif(this.tail !== null){\n\t\t\tthis.tail.next = newNode;\n\t\t\tnewNode.prev = this.tail;\n\t\t}\n\t\telse{\n\t\t\tthis.head.next = newNode;\n\t\t\tnewNode.prev = this.head;\n\t\t}\n\t\tthis.tail = newNode;\n\t}\n\treturn newNode;\n}\n\ndLinkedList.prototype.insertAfter = function(refNode,inObj){\n\t\n\tvar newNode = dLinkedList.makeNode(inObj);\n\n\tif((this.tail === null)||(this.tail === refNode)){\n\t\t//only scenario this happens is if you only have one head node\n\t\tthis.tail = newNode;\n\t\tnewNode.prev = refNode;\n\t\trefNode.next = newNode;\n\t}\n\telse{\n\t\tvar nextNode = refNode.next;\n\n\t\t//insert node inbetween\n\t\trefNode.next = newNode;\n\t\tnewNode.prev = this.refNode;\n\t\tnewNode.next = nextNode;\n\t\tnextNode.prev = newNode.next;\n\t}\n\treturn newNode;\n};\n\ndLinkedList.prototype.insertBefore = function(refNode,inObj){\n\tvar newNode = dLinkedList.makeNode(inObj);\n\t//if list only has one element\n\tif(this.tail === null){\n\t\tthis.tail = refNode;\n\t\trefNode.prev = newNode;\n\t\tthis.head = newNode;\n\t}\n\telse{\n\t\tvar prevNode = refNode.prev;\n\t\trefNode.prev = newNode;\n\t\tnewNode.next = refNode;\n\t\t//if refNode doesn't have a prev, it is the head of the list and the head needs to be changed\n\t\tif(prevNode === null){\n\t\t\tthis.head = newNode;\n\t\t}\n\t\telse{\n\t\t\tprevNode.next = newNode;\n\t\t\tnewNode.prev = prevNode;\n\t\t}\n\t}\n\n\treturn newNode;\n};\n//finds the first node that has the obj\ndLinkedList.prototype.findFirst = function(obj){\n\tvar currentNode = this.head;\n\twhile(currentNode !== null){\n\t\tif(currentNode.obj === obj){\n\t\t\treturn currentNode;\n\t\t}\n\t\tcurrentNode = currentNode.next;\n\t}\n\treturn undefined;\n};\n\ndLinkedList.prototype.remove = function(delNode){\n\tvar prevNode = null;\n\tvar currentNode = this.head;\n\n\twhile(currentNode !== null){\n\n\t\tif(currentNode === delNode){\n\n\t\t\tif(currentNode === this.head){\n\t\t\t\tvar nextNode = currentNode.next;\n\t\t\t\tthis.head = nextNode;\n\t\t\t\tthis.head.prev = null;\n\t\t\t}\n\t\t\telse if(currentNode === this.tail){\n\t\t\t\tthis.tail = currentNode.prev;\n\t\t\t\tthis.tail.next = null;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tvar nextNode = currentNode.next;\n\t\t\t\tprevNode.next = nextNode;\n\t\t\t\tnextNode.prev = prevNode;\n\t\t\t}\n\t\t\tcurrentNode = null;\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\tprevNode = currentNode;\n\t\tcurrentNode = currentNode.next;\n\t}\n\n\treturn false;\n};\n\n//iterate takes 3-4 arguments\n//1. callback (required), returns true if you want to continue (return true to apply to all nodes)\n//2. isForward: true for forwards iteration(required) or false backwards iteration\n//3. starting node\n//4. arg: optional, if you need to plug arguments into callback\ndLinkedList.prototype.iterate = function(){\n\t\tvar callback = arguments[0];\n\t\tvar isForward = arguments[1];\n\t\tvar arg = null;\n\t\tif(arguments[3] !== null){\n\t\t\targ = arguments[3];\n\t\t}\n\n    var currentNode = arguments[2];\n    callback(currentNode);\n\n    if(isForward){\n    \tcurrentNode = currentNode.next;\n    }\n    else{\n    \tcurrentNode = currentNode.prev;\n    }\n\n    while(currentNode != null){\n    \t\tvar isContinue;\n\n    \t\tif(arg !== null){\n\t\t\t\t\tisContinue = callback(currentNode,arg);\n    \t\t}\n    \t\telse{\n\t\t\t\t\tisContinue = callback(currentNode);\n    \t\t}\n\n        if(isContinue !== true){\n        \tbreak;\n        }\n\n        if(isForward){\n        \tcurrentNode = currentNode.next;\n        }\n        else{\n        \tcurrentNode = currentNode.prev;\n        }\n    }\n};\n\n//applyToEveryNode takes 1-2 arguments\n//1. callback (required), returns true if you want to continue (return true to apply to all nodes)\n//2. arg: optional, if you need to plug arguments into callback\n\ndLinkedList.prototype.applyToEveryNode = function(){\n\tvar callback = arguments[0];\n\tvar arg = arguments[1];\n\n\tif(arg === null){\n\t\tvar wrapper = function(currentNode){\n\t\t\tcallback(currentNode);\n\t\t\treturn true;\n\t\t}\n\t\tthis.iterate(wrapper,true,this.head);\n\t}\n\telse{\n\t\tvar wrapper = function(currentNode,cbArg){\n\t\t\tcallback(currentNode,cbArg);\n\t\t\treturn true;\n\t\t}\n\t\tthis.iterate(wrapper,true,this.head,arg);\n\t}\n\n}\n\nwindow.dLinkedList = dLinkedList;\n\nmodule.exports = dLinkedList;\n"]}